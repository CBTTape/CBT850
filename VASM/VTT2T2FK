   TITLE 'VTT2T2FK -- READ A REAL TAPE AND CREATE FAKETAPE FILE'
**************************************************************
**************************************************************
**                                                          **
**                                                          **
**  MODULE:  VTT2T2FK.   Written by Sam Golob               **
**                                                          **
**       Copyright (c) 2001-2005 by Sam Golob               **
**                                                          **
**       A component of the:                                **
**       Virtual Tape Transportation System (VTTS)          **
**                                                          **
**  PURPOSE:  Program to read in a tape, and create an      **
**            MVS disk file in "folded FB-80 FAKETAPE       **
**            format".                                      **
**                                                          **
**     The output of this program is intended to be input   **
**     for the VTT2FK2T program.  These two programs,       **
**     VTT2T2FK and VTT2FK2T, are designed to work          **
**     together, as paired and opposite programs.           **
**                                                          **
**  OBSERVATION:  Although this program is purely an MVS    **
**                program, the FAKETAPE output of this      **
**     program can be downloaded to other systems where     **
**     the file can actually be interpreted as an emulated  **
**     tape.  This is one way of transferring tape data to  **
**     other MVS systems that can read FAKETAPE tape        **
**     files directly, as though they were tapes.           **
**                                                          **
**     For example, you can take mainframe-based tapes      **
**     on real cartridges and create FAKETAPE-compatible    **
**     files that can be read on a FLEX-ES system.          **
**                                                          **
**     FAKETAPE files do not currently support chunked      **
**     blocks, but I have preserved the structure of the    **
**     VTT2DISK program here, so that if chunked blocks     **
**     will be supported later by FAKETAPE, then it will    **
**     be relatively easy to put in support for them.  We   **
**     pretend, in the logic of this program, that there    **
**     is a maximum chunk size of 65535, so that all 64K    **
**     blocks will come out with "chunksize equals          **
**     blocksize" treatment.                                **
**                                                          **
**  METHOD:                                                 **
**                                                          **
**     Tape data is read into a data buffer in this         **
**     program.  Each block is read in, and its size        **
**     is determined.  This size is compared to the 65535   **
**     byte chunk size, and a decision is made as to what   **
**     to do.  A FAKETAPE header is made for each chunk.    **
**     Each FAKETAPE header is folded into FB-80 output,    **
**     and then the data is folded in afterward, until      **
**     the block, and its associated FAKETAPE header, is    **
**     folded in.  Then another tape block is read into     **
**     the buffer, and the process repeats.                 **
**                                                          **
**     When the tape file ends, and a tape mark is read     **
**     in, a FAKETAPE header with "zero next bytes" is      **
**     constructed.  This indicates a tape mark written.    **
**     That header is then folded into the FB-80 output     **
**     dataset after the last data.  The first header for   **
**     the next file, if any, immediately follows.          **
**                                                          **
**     At the end of the tape, an end-of-tape FAKETAPE      **
**     header is appended to the end of the output          **
**     file and folded in.  The last FB-80 record           **
**     is completed with X'30's, if necessary.  This may,   **
**     depending on how many of them there are, signify     **
**     more tape marks at the end of the FAKETAPE file.     **
**     Since the last 80-byte record has to be completed    **
**     with some kind of data, it seemed that X'30's,       **
**     which are what FLEX-ES itself produces at the end    **
**     of FAKETAPE files, are the safest things to put      **
**     there.                                               **
**                                                          **
**     This program was adapted from version 1.12 of the    **
**     VTT2DISK program, which is part of the Virtual       **
**     Tape Transportation System (VTTS), copyright (c)     **
**     2001-2005 by Sam Golob.                              **
**                                                          **
**     All of the "FB-80 folding" work is now done by the   **
**     sub-program called FOLDEM.  The FOLDEM program       **
**     operation is completely controlled by a control      **
**     block called the FLDAREA control block, which does   **
**     all of the communication between the main program    **
**     and the FOLDEM sub-program.  Therefore, monitoring   **
**     of the folding process is now possible purely by     **
**     displaying the current status of the FLDAREA         **
**     fields.  A convenient routine for displaying the     **
**     status of the FLDAREA fields is the FLDIMAGE         **
**     routine in either program, which is invoked by:      **
**                                                          **
**     BAL   R9,FLDIMAGE                                    **
**                                                          **
**     Therefore the fold monitoring displays that used     **
**     to be in the SYSMOVED DD name, are now obsolete.     **
**                                                          **
**     There are two more fields in the FLDAREA control     **
**     block than in the UNFAREA control block of the       **
**     UNFOLDEM sub-program that VTT2FK2T uses.  These      **
**     are:                                                 **
**                                                          **
**           FLDBYTOT - bytes left in buffer after the      **
**                      last chunk of data was folded       **
**           FLDREADF - propagation of the "read only"      **
**                      flag into the sub-program           **
**                                                          **
**     These extra fields are obviously not required by     **
**     the unfolding process.  The first one is not         **
**     required because you're doing "unchunking" instead   **
**     of "chunking", and you read the existing chunks      **
**     as they come in; you're not required to create       **
**     them.  The second one is not required because the    **
**     main program writes the output (a tape) instead of   **
**     the sub-program writing the output (an FB-80 file).  **
**     So in our case, in a READ only situation, the        **
**     sub-program must know when to NOT produce FAKEOUT    **
**     output.                                              **
**                                                          **
**  OPTIONAL DDNAMES:                                       **
**                                                          **
**     In order to make sure that the VTT2T2FK program      **
**     is doing its job properly, it produces a lot of      **
**     trace data and status data, as it is creating        **
**     the folded FB-80 FAKETAPE format tape.  In order     **
**     not to clutter the summary report, most of this      **
**     data is written to "Optional DDNAMEs".  Starting     **
**     with version 1.12 of this program, most of the       **
**     trace data now consists of the state of the FLDAREA  **
**     control block fields at various stages of program    **
**     execution.                                           **
**                                                          **
**     If you have access to the source code (you are       **
**     reading it), you can introduce an instruction:       **
**                                                          **
**           BAL   R9,FLDIMAGE                              **
**                                                          **
**     at any point in the program, as long as SYSPRINT     **
**     is open.  This should produce any diagnostics you    **
**     may need, because all FLDAREA fields are displayed.  **
**                                                          **
**     Optional DDNAMEs don't have to be coded in the       **
**     JCL.  But if they are coded, they will contain       **
**     the extra trace data which VTT2T2FK produces,        **
**     and the SYSFILES ddname will contain a detailed      **
**     "file by file" report.                               **
**                                                          **
**     The SYSFILES report is very useful if you want       **
**     to do a "dry run", with the READ parameter.  If      **
**     you want to know the structure of a tape without     **
**     creating the FB-80 output file, the SYSFILES         **
**     report will tell you what files are on the tape.     **
**     It will also give you an indication of how big an    **
**     FB-80 output file you will need on an MVS disk,      **
**     to contain all the tape data.  See below for         **
**     details.                                             **
**                                                          **
**     The optional DDNAMEs are SYSTRACE, SYSFILES,         **
**     and SYSIN.  SYSMOVED is now obsolete, although       **
**     it will produce a dummy report if it is present      **
**     in the JCL.                                          **
**                                                          **
**     SYSIN data is necessary if optional parameters       **
**     are to be entered, such as:                          **
**                                                          **
**     NEWVOL=volser                                        **
**     READ                                                 **
**     IDRCOFF                                              **
**                                                          **
**     SYSIN keywords have to start in column 1.            **
**                                                          **
**     Either READ or IDRCOFF can also be entered in the    **
**     PARM field of the EXEC card in the JCL.              **
**                                                          **
**     Full JCL to run the VTT2T2FK program is as           **
**     follows:                                             **
**                                                          **
**     //   jobcard                                         **
**     //TAPEREAD EXEC PGM=VTT2T2FK                         **
**     //STEPLIB   DD  DISP=SHR,DSN=your.load.library       **
**     //FAKEOUT   DD  DSN=fb80.folded.faketape,            **
**     //          DISP=(NEW,CATLG,DELETE),UNIT=SYSALLDA,   **
**     //          VOL=SER=volxxx,                          **
**     //          SPACE=(CYL,(mm,nn),RLSE)                 **
**     //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)    **
**     //TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TEST01,    **
**     //          LABEL=(1,BLP,EXPDT=98000)                **
**     //SYSPRINT  DD  SYSOUT=*                             **
**     //SYSFILES  DD  SYSOUT=*                             **
**     //SYSTRACE  DD  SYSOUT=*                             **
**     //SYSUDUMP  DD  SYSOUT=*                             **
**     //SYSIN     DD  *                                    **
**     keywords in column 1                                 **
**     /*                                                   **
**                                                          **
**     where you can leave out SYSTRACE and SYSUDUMP        **
**     if you want to.  I'd strongly suggest including      **
**     (at least) SYSFILES, though.                         **
**                                                          **
**     SYSTRACE takes a picture of the tape buffer at       **
**     READ time, and takes a picture of the AWS headers    **
**     and the FLDAREA control block fields at the time     **
**     the headers are made.  Since the folding is now      **
**     done by the FOLDEM subprogram, SYSMOVED, which       **
**     used to track the data folding process, is now       **
**     not necessary.  Of course SYSUDUMP is there to       **
**     contain the MVS-produced dump, upon any abnormal     **
**     termination of the program.                          **
**                                                          **
**     SYSFILES gives you block counts and byte counts      **
**     for all files read and written.                      **
**                                                          **
**     In the SYSPRINT report, there is a count of total    **
**     number of 80-byte records which the program will     **
**     (or has) put out.  If you are doing a READ only      **
**     run, and want to allocate an output file which is    **
**     the right size, you might use this number, together  **
**     with the BLKnnnn command from File 296 of the CBT    **
**     Tape, to produce the following result:               **
**                                                          **
**     Say, our program produces:                           **
**                                                          **
**     TOTAL NUMBER OF RECORDS OUT:            4,152,837    **
**                                                          **
**     And you want to allocate space on a 3390.  So you    **
**     would say:                                           **
**                                                          **
**     BLK3390 80 BLKSIZE(27920) RECORDS(4152837)           **
**                                                          **
**     Which comes up with the result:                      **
**                                                          **
** FOR BLKSIZE 27,920  AND 4,152,837 RECORDS, ALLOCATE:     **
**    11,900 BLOCKS,     5,950 TRACKS, OR   397 CYLINDERS   **
**                                                          **
**  CHANGE LOG:                                             **
**                                                          **
**    Version 1.12 - Re-architected program to use FOLDEM   **
**       sub-program for data moves.  The FOLDEM program    **
**       is driven by the FLDAREA control block, so the     **
**       trace data consists mostly of the state of the     **
**       FLDAREA control block fields.  A routine called    **
**       FLDIMAGE will print all the FLDAREA control block  **
**       fields on a single SYSPRINT line.                  **
**                                                          **
**       Added the possibility of coding program options    **
**       in the SYSIN DD, which is used if it is present    **
**       in the JCL.  SYSIN keywords, which must be coded   **
**       to start in column 1, are currently:               **
**                                                          **
**       NEWVOL=volser                                      **
**       READ                                               **
**       IDRCOFF                                            **
**                                                          **
**       This program was adapted from Version 1.12 of      **
**       the VTT2DISK program, so its initial version       **
**       is also called Version 1.12.                       **
**                                                          **
**       The NEWVOL=volser keyword in SYSIN, allows you     **
**       to change the volser in the VOL1 label of the      **
**       output FAKETAPE tape file.                         **
**                                                          **
**       Now, the READ and IDRCOFF keywords of the EXEC     **
**       PARM field, can also be coded in SYSIN.  They      **
**       must begin in column 1.  READ allows a dry run     **
**       of the program which reads the input tape and      **
**       reports statistics, but which does not produce     **
**       an output FB-80 AWS file.                          **
**                                                          **
**       IDRCOFF looks in the tape standard labels, if      **
**       there are any, and turns off any "P" indicators    **
**       which tell MVS that this tape was produced on      **
**       an IDRC-enabled tape drive.  Since the output      **
**       FB-80 file is not compressed anyway, one wants     **
**       the power to read the FAKETAPE tape file on a      **
**       logical 3420 or 3480 tape drive, without MVS       **
**       telling you that "the tape has compressed files    **
**       and I can't read it" on this particular drive.     **
**                                                          **
**                                                          **
**************************************************************
         EJECT
**************************************************************
         MACRO
*  ---------------------------------------------------------------  *
*    This macro is used to display hex values in a printed report.  *
*  ---------------------------------------------------------------  *
&NAME    HEX   &TO,&LEN,&FROM
&NAME    DS    0H
         ST    R4,SAVER4B
         STM   15,1,HEXSAVE
         LA    1,&FROM
         LA    0,&LEN
         LA    15,&TO
         BAL   4,HEX
         L     R4,SAVER4B
         LM    15,1,HEXSAVE
         MEND
         SPACE
**************************************************************
         GBLC  &LLEV
         GBLC  &DEFCHKC
         GBLA  &DEFCHNK
&LLEV    SETC  '1.12'
* ------------------------------------------------------------------ *
*   DEFAULT CHUNKSIZE FOR THE OUTPUT FB-80 AWS FILE PRODUCED BY      *
*   THIS PROGRAM, IS SET HERE.  AS DISTRIBUTED, THE VALUE IS 65535.  *
* ------------------------------------------------------------------ *
*   FAKETAPE does not support chunking of blocks, but if the         *
*   chunk size is set to the largest possible value for a 64K        *
*   block size limit, all chunksizes will equal the block sizes.     *
* ------------------------------------------------------------------ *
&DEFCHNK SETA  65535
&DEFCHKC SETC  '&DEFCHNK'
         YREGS
         EJECT
** -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- **
VTT2T2FK CSECT
*                           It is probably not necessary to run
*                           this program in 24-bit mode.  But
*                           it works when it is run that way.
VTT2T2FK AMODE 24
VTT2T2FK RMODE 24
         USING *,R15
         B     EYECATCH
         DC    C'--- '            MAKE EYECATCHER VISIBLE
         DC    C'VTT2T2FK - REAL TAPE TO FOLDED FAKETAPE DISK FILE - '
         DC    C'LEVEL '
SYSLEV   DC    C'&LLEV'
         DC    C' - '
SYSDAT   DC    C'&SYSDATE'
         DC    C'  ',C'&SYSTIME ',C'--- '
         DC    C'Copyright (c) 2001-2005 by Sam Golob '
SAVEAREA DC    18F'0'
EYECATCH DS    0D                    ENSURE ALIGNMENT
         SAVE  (14,12)
         LR    R5,R1                 SAVE PARM POINTER
         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR
         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR
         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR
         LR    R13,R1                NEW SAVE AREA ADDRESS
         DROP  R15
* -----                              SET UP BASE REGISTERS
         USING VTT2T2FK,R12,R11,R10,R8,R7
         LR    R12,R15
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LA    R8,4095(,R10)
         LA    R8,1(,R8)
         LA    R7,4095(,R8)
         LA    R7,1(,R7)
         LR    R1,R5                 RESTORE PARM POINTER
*
* ----- >                            Parms          <--- below
         L     R1,0(R1)              Get PARM field
         CLC   =C'READ',2(R1)        Is it "READ" only?
         BE    COPYREAD              Yes. Turn on indicator.
         CLC   =C'IDRCOFF',2(R1)     Do we turn off IDRC indicators?
         BE    COPYIDRF              Yes. Say that.
         B     COPYTAPE              No. Just go on with processing.
COPYREAD DS    0H                    READ only?
         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.
         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.
         B     COPYTAPE
COPYIDRF DS    0H                    IDRC indicators off?
         OI    IDRCFLAG,X'01'        Yes. Turn on flag.
         B     COPYTAPE
*  Note:  READ and IDRCOFF can also be set in SYSIN in column 1.
COPYTAPE DS    0H
* ----- >                            Parms          <--- above
*
***********************************************************************
* GET SYSTEM DATE AND TIME - A standard way to get date and time      *
***********************************************************************
         STM   R14,R2,SAVE1402
         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY
         OI    DATE+4,X'0F'
         UNPK  DATED,DATE
         OI    TIME+3,X'0F'
         UNPK  TIMED,TIME
*                          FILL HEADDATE AREA WITH INFO TO REUSE
         MVC   HEADDATE(2),DATED
         MVI   HEADDATE+2,C'/'
         MVC   HEADDATE+3(2),DATED+2
         MVI   HEADDATE+5,C'/'
         MVC   HEADDATE+6(4),DATED+4
         MVC   HEADDATE+12(2),TIMED
         MVI   HEADDATE+14,C':'
         MVC   HEADDATE+15(2),TIMED+2
         MVI   HEADDATE+17,C':'
         MVC   HEADDATE+18(2),TIMED+4
         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time
         MVC   MESSAGE2+88(31),HEADDLIT      in the reports.
         MVC   MESSAGE3+88(31),HEADDLIT
         MVC   MESSAGE4+88(31),HEADDLIT
         LM    R14,R2,SAVE1402
***********************************************************************
         MVC   LEVDATE(8),SYSDAT
***********************************************************************
         MVC   MESSAGE1+61(21),LEVELLIT    Program level and
         MVC   MESSAGE2+61(21),LEVELLIT      assembly date
         MVC   MESSAGE3+61(21),LEVELLIT
         MVC   MESSAGE4+61(21),LEVELLIT
***********************************************************************
* ----------------------------------------------------------------- *
INITEM   DS    0H                    Initialize some constants
         MVC   FOLDHIGH(2),=X'0000'  High order of fullwords.
         MVC   FULLHIGH(2),=X'0000'
         MVC   CURRBYTE(2),=X'0000'
         MVC   LASTBYTE(2),=X'0000'
         MVC   HDRSIZE(4),=F'12'     Set size of header globally.
         MVC   FLDOFFST(4),=F'0'     Offset is initially zero
         LA    R1,OUTCARD            Let FOLDEM know about FAKEOUT area
         ST    R1,FLDSCARD           Beginning of card image output
         ST    R1,SVBEGCRD
         LA    R1,80(,R1)            Find end of card
         ST    R1,FLDECARD           And store it away for the duration
         ST    R1,SVENDCRD
         L     R1,=A(INAREA)         Get address of input buffer
         ST    R1,SVBFAREA           And save it away.
         ST    R1,FLDBUFFR           Prime these fields
         ST    R1,FLDBSTRT
         L     R0,=F'&DEFCHNK'       Set default chunk size.
         ST    R0,CHNKSIZE           Default is X'FFFF' unless changed.
         ZAP   FLDOUTCT,=P'0'        Zero count of FAKEOUT records.
* ----------------------------------------------------------------- *
TIOTSCAN DS    0H             Determine the presence of Optional
*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES
* ----->                      and open them if there is JCL for them.
* ----------------------------------------------------------------- *
         L     R5,16          R5=CVT
         L     R5,0(,R5)      R5=TCB WORDS
         L     R5,4(,R5)      R5=MY TCB
         L     R5,12(,R5)     R5=TIOT
         LA    R5,24(,R5)     R5=FIRST DD ENTRY
TIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?
         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES
         CLC   4(8,R5),SYSTRACE+40  SYSTRACE ddname there?
         BNE   TIOTMOVD       NO
         OI    FLAGSYST,X'01'       Flag presence of SYSTRACE DD
         B     TIOTNEXT       CONTINUE
TIOTMOVD CLC   4(8,R5),SYSMOVED+40  SYSMOVED ddname there?
         BNE   TIOTFILE
         OI    FLAGSYST,X'02'       Flag presence of SYSMOVED DD
         B     TIOTNEXT
TIOTFILE CLC   4(8,R5),SYSFILES+40  SYSFILES ddname there?
         BNE   TIOTSYSN
         OI    FLAGSYST,X'04'       Flag presence of SYSFILES DD
         B     TIOTNEXT
TIOTSYSN CLC   4(8,R5),SYSIN+40     SYSIN ddname there?
         BNE   TIOTNEXT
         OI    FLAGSYST,X'08'       Flag presence of SYSIN DD
         B     TIOTNEXT
TIOTNEXT SR    R3,R3
         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY
         AR    R5,R3          R5=NEXT DD ENTRY
         B     TIOTLOOP       GO CHECK IT
TIOTSEND DS    0H
* ----------------------------------------------------------------- *
* ---    DO SYSIN PROCESSING IF THE DD IS THERE                 --- *
* ----------------------------------------------------------------- *
*
         BAL   R9,SCNSYSIN           Scan SYSIN for all its info.
*
* ----------------------------------------------------------------- *
***********************************************************************
*    Now OPEN the files and start the processing.
***********************************************************************
* - - - ->  Chunk Size Message - - - ->   below
*    The purpose of this code is to fill MESSAG14 with information.
         L     R1,CHNKSIZE                  Load binary Chunk Size
         XC    DWORD,DWORD                  Clear DWORD to zeros.
         CVD   R1,DWORD                     Convert to decimal.
         OI    DWORD+7,X'0F'                Make sign readable.
         MVC   MESSAG14+28(8),CHPATTRN      Load pattern into message
         ED    MESSAG14+28(8),DWORD+4       Edit the number
         B     AFCHKDSP                     Branch past constant
CHPATTRN DC    X'4020202020202120'          8 bytes of pattern
AFCHKDSP DS    0H
* - - - ->  Chunk Size Message - - - ->   above
         TM    READFLAG,X'01'        Read Only run?
         BO    NOFAKOUT              Yes. Don't OPEN FAKEOUT.
         OPEN  (FAKEOUT,(OUTPUT))
NOFAKOUT DS    0H
         OPEN  (SYSPRINT,(OUTPUT))
         OPEN  (TAPIN,(INPUT))
*--->>
         MVC   MSGLINE1,MSGLINE1-1   Clear optional
         MVC   MSGLINE2,MSGLINE2-1      message lines
READIDRC DS    0H
         TM    READFLAG,X'01'        READ only run?
         BZ    IDRCMSG
READMSG  DS    0H
         MVC   MSGLINE1+4(21),=C'This Run is READ ONLY'
IDRCMSG  DS    0H
         TM    IDRCFLAG,X'01'        Remove IDRC indicator from labels?
         BZ    ENDEXMSG
         MVC   MSGLINE2+4(24),=C'Turn IDRC indicators off'
ENDEXMSG DS    0H
*--->>
TRACERPT DS    0H
         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?
         BNO   MOVEDRPT              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSTRACE,(OUTPUT))
         PUT   SYSTRACE,MESSAGE2     Title message for SYSTRACE report
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE      Blank Line
         PUT   SYSTRACE,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    TRACENOI
         PUT   SYSTRACE,MSGLINE2     IDRC remove message
TRACENOI DS    0H
*        PUT   SYSTRACE,MESSAG14
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
TRACDESC DS    0H
         PUT   SYSTRACE,MESSAGE8
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
         PUT   SYSTRACE,MESSAGE5
         PUT   SYSTRACE,MESSAGE6
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
         PUT   SYSTRACE,MESSAG11
         PUT   SYSTRACE,MESSAG12
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
         PUT   SYSTRACE,MESSAGE7
*--->>
MOVEDRPT DS    0H
         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?
         BNO   FILESRPT              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSMOVED,(OUTPUT))
         PUT   SYSMOVED,MESSAGE3     Title message for SYSMOVED report
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE      Blank Line
         PUT   SYSMOVED,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    MOVEDNOI
         PUT   SYSMOVED,MSGLINE2     IDRC remove message
MOVEDNOI DS    0H
*        PUT   SYSMOVED,MESSAG14
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE
         PUT   SYSMOVED,MESSAGE9
         PUT   SYSMOVED,MESSAG10
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE
         PUT   SYSMOVED,MESSAG11
         PUT   SYSMOVED,MESSAG12
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE
*--->>
FILESRPT DS    0H
         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?
         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSFILES,(OUTPUT))
         PUT   SYSFILES,MESSAGE4     Title message for SYSFILES report
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSFILES,OUTLINE      Blank Line
         PUT   SYSFILES,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    FILESNOI
         PUT   SYSFILES,MSGLINE2     IDRC remove message
FILESNOI DS    0H
*        PUT   SYSFILES,MESSAG14
*--->>
NOSYSFIL DS    0H
* ----------------------------------------------------------------- *
*   Now do the same for SYSPRINT report, which is always there.
* ----------------------------------------------------------------- *
         PUT   SYSPRINT,MESSAGE1
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         PUT   SYSPRINT,OUTLINE      Blank Line
         PUT   SYSPRINT,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    PRINTNOI
         PUT   SYSPRINT,MSGLINE2     IDRC remove message
PRINTNOI DS    0H
*        PUT   SYSPRINT,MESSAG14
*--->>
*  TEST TEST TEST TEST TEST TEST TEST TEST TEST  Move as needed.
*        BAL   R9,FLDIMAGE
*--->>
* ----------------------------------------------------------------- *
TAPEREAD DS    0H                      READ a new tape block.
* ----------------------------------------------------------------- *
*   You come here every time you do a tape READ.
* ----------------------------------------------------------------- *
         NI    TPMKFLAG,X'FF'-X'02'    You haven't read two tape marks
         BAL   R9,READBLOK             Read a block of data
         TM    TPMKFLAG,X'01'          Was this read a Tape Mark?
         BO    MAINTPMK                Yes. Take appropriate action.
* --- >
         L     R1,CURRBFUL             Fullword number of bytes read
         C     R1,CHNKSIZE             Bigger than chunk size?
         BNH   NOCHUNKS                No. Don't chunk. X'A0' headers.
         OI    CHNKFLAG,X'01'          Yes. Headers to be chunked.
         NI    BUFINISH,FF-X'01'       Turn "buffer finished" flag off
         MVC   FLDBYTOT,CURRBFUL       Total bytes in buffer
         MVC   FLDBYTES,CHNKSIZE       Chunk size is bytes to be moved
         B     AFTRCHNK                Jump over other alternative
NOCHUNKS DS    0H
         NI    CHNKFLAG,FF-X'01'       Say it ain't so, Joe.
         OI    BUFINISH,X'01'          Buffer is finished in one shot.
         MVC   FLDBYTOT,CURRBFUL       Bytes in buffer is true total
         MVC   FLDBYTES,CURRBFUL       Bytes in buffer is current total
* --- >                                Label check if HDR - below
AFTRCHNK DS    0H
         CLC   CURRBYTE,=X'0050'       Exactly 80 bytes read?
         BNE   MAINNOTL                No. Can't be a label.
         BAL   R9,LABELCHK             Check for labels and their kind.
         TM    ISLBLFLG,X'01'          Is this record a label?
         BZ    MAINNOTL                No. Bypass flag setting.
         TM    LBLFLAG,X'03'           Is this label a HDR1 or HDR2?
         BZ    MAINNOTH                Neither. Check if EOF or EOV.
         OI    FLAGHDRL,X'01'          Flag just after a HDR 1 or 2.
MAINNOTH DS    0H
         TM    LBLFLAG,X'F0'           Is label an EOF or EOV?
         BZ    MAINNOTL                No. Don't turn off flag.
         NI    FLAGHDRL,FF-X'01'       After EOF or EOV. Turn flag off.
MAINNOTL DS    0H
* ----------------> BYTE COUNTS AT THE READ LEVEL  -  BELOW
** -->              stuff below is only done per READ.
         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3
         L     R2,CURRBFUL          Load Current READ Byte Count
         LA    R3,DBOUTF            Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         LA    R3,DBOUT             Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
** -->   label byte counts and data byte counts  <-- **  below
         TM    ISLBLFLG,X'01'       This is a label file?
         BO    ADLABCNT             If so, go count its bytes
         LA    R3,DAIN              This is a data file--count bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         B     NOLABCNT             Don't count twice
ADLABCNT DS    0H
         LA    R3,LBIN              Count the label file's bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
NOLABCNT DS    0H
         LM    R2,R3,SAVEMOVE       Save prev contents of R2 and R3
** -->              stuff above is only done per READ.
* ----------------> BYTE COUNTS AT THE READ LEVEL  -  ABOVE
* --- >                                Label check if HDR - above
**-------------------------------------------------------------------**
FOLDSTRT DS    0H                   MAKE HEADERS AND FOLD DATA UNTIL
*                                   THE BUFFER IS EXHAUSTED.
         MVC   FLDSCARD,SVBEGCRD       Prime the FLDAREA card fields
         MVC   FLDECARD,SVENDCRD
         L     R3,=A(INAREA)           Point to the data buffer
         ST    R3,FLDBUFFR             Initialize
         ST    R3,FLDBSTRT                 FLDAREA fields
         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA
*                                      because we'll have to fold the
*                                      newly manufactured header.
**-------------------------------------------------------------------**
FOLDLOOP DS    0H
         L     R1,FLDBYTOT          Compare bytes remaining to fold
         C     R1,CHNKSIZE          To the chunk size.
         BH    FOLDNCHK             If now less than or equal
         NI    CHNKFLAG,FF-X'01'    Turn the chunk flag off
         OI    BUFINISH,X'01'       And turn "buffer finished" flag on
         MVC   FLDBYTES,FLDBYTOT    Only move bytes that are left.
FOLDNCHK DS    0H
         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA
         BAL   R9,MAKEHEDR             Create a header with READ info
         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold
         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold
         LA    R3,HEADER               Point to address of this header
         ST    R3,FLDBUFFR             Store it into FLDAREA fields
         ST    R3,FLDBSTRT
         BAL   R9,FOLDBUFF             And fold it into FB-80.
         MVC   SAVOFFST(4),FLDOFFST    Offset has to be current.
         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too
         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore entire FLDAREA
         MVC   FLDBYMVD,=F'0'          Initialize bytes folded
         BAL   R9,FOLDBUFF             And fold it into the output.
         NI    NWBLKFLG,FF-X'01'    Only first chunk is from new block
** ---------- >>    Record the number of bytes folded - below
         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3
         L     R2,FLDBYMVD          Load Current folded Byte Count
         LA    R3,DBOUTFM           Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         LA    R3,DBOUTM            Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
NOFLDCNT DS    0H
         LM    R2,R3,SAVEMOVE       Save prev contents of Register 2
** ---------- >>    Record the number of bytes folded - above
         TM    CHNKFLAG,X'01'          Are we doing chunks?
         BZ    TAPEREAD                No. Do another tape read.
         TM    BUFINISH,X'01'          Have we finished this block?
         BO    TAPEREAD                Yes. Read another block.
         B     FOLDLOOP                No. Fold more chunks.
*
MAINTPMK DS    0H                   Last read was a T.M.
         AP    TPMKCNT,=P'1'        Add 1 to Tape Mark count
         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk
         BAL   R9,MAKEHEDR          Make a header to show EOF.
         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold
         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold
         LA    R3,HEADER            Load address of header
         ST    R3,FLDBUFFR          Store it into FLDAREA fields
         ST    R3,FLDBSTRT
         BAL   R9,FOLDBUFF          Fold the header into the output
         MVC   SAVOFFST,FLDOFFST    Offset has to be current
         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too
         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore after folding header
         BAL   R9,REPTFILE          Report Block and Byte Counts
*--->>
         MVC   DBOUTF(8),=D'0'      Zero File Byte Count
         MVC   DBOUTFM(8),=D'0'     Zero File Byte Count
         ZAP   BLOCKCNT,=P'0'       Zero File Block Count
*--->>
         B     TAPEREAD             Read in another tape block.
*
* ---------------------------------------------------------------- *
*          END OF INPUT TAPE DATA                                  *
* ---------------------------------------------------------------- *
FIN      DS    0H                   PROGRAM EXIT ROUTINE
         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk
         OI    TPMKFLAG,X'01'       Force Tape Mark indication.
         BAL   R9,MAKEHEDR          Make EOT header
         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold
         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold
         LA    R3,HEADER            Load address of header
         ST    R3,FLDBUFFR          Store it into FLDAREA fields
         ST    R3,FLDBSTRT
         BAL   R9,FOLDBUFF          Fold the header into the output
BREAKLUP DS    0H
         MVC   SAVOFFST,FLDOFFST    Offset has to be current
         MVC   SAVOUTCT,FLDOUTCT    Card count should be current too
         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore FLDAREA control blk
         TM    READFLAG,X'01'       READ only?
         BO    NOPUT01              Yes. No output to FAKEOUT.
         PUT   FAKEOUT,OUTCARD      And write out the last buffer.
NOPUT01  DS    0H
         AP    FLDOUTCT,=P'1'       Count the record PUT out.
WRITSUMM DS    0H
         BAL   R9,SUMMREPT          Print the summary report.
* ---------------------------------------------------------------- *
*     Close the files that were OPENed
* ---------------------------------------------------------------- *
CLOSEMAL DS    0H                   Close em all.....
         CLOSE TAPIN
         TM    READFLAG,X'01'       Is this a READ only run?
         BO    NOFKOCLS             Can't CLOSE what ain't OPEN.
         CLOSE FAKEOUT
NOFKOCLS DS    0H
         CLOSE SYSPRINT
         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?
         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSTRACE
SYSTRNOP DS    0H
         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?
         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSMOVED
SYSFILNO DS    0H
         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSFILES DDNAME?
         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSFILES
SYSMVDNO DS    0H
FIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM
         L     R13,4(,R13)
         RETURN (14,12),RC=0
         EJECT
* ----------------------------------------------------------------- *
* ---       SUBROUTINES                                         --- *
* ----------------------------------------------------------------- *
*
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
*   Input :  R1 points to 2-byte binary number.  LA    R1,BINNUM
*   Output:  ASCWORK contains the 4-byte ASCII equivalent.
ASCCNVRT DS    0H
         ST    R9,SAVER9AC
         HEX   ASCWORK,2,0(R1)
         TR    ASCWORK(4),TRASCNUM
ASCCNVRE DS    0H
         L     R9,SAVER9AC
         BR    R9
         DS    CL2
ASCWORK  DS    XL4
         DS    CL2
TRASCNUM DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30414243444546303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30303030303030303030303030303030'
         DC    XL16'30313233343536373839303030303030'
TRTA2E   DS    0D                                                        05559
         DC    XL16'000102030405060708090A0B0C0D0E0F'                    05560
         DC    XL16'101112131415161718191A1B1C1D1E1F'                    05561
         DC    XL16'405A7F7B5B6C507D4D5D5C4E6B604B61'                    05562
         DC    XL16'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'                    05563
         DC    XL16'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'                    05564
         DC    XL16'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'                    05565
         DC    XL16'79818283848586878889919293949596'                    05566
         DC    XL16'979899A2A3A4A5A6A7A8A9C04FD0A17F'                    05567
         DC    XL16'808182838485868788898A8B8C8D8E8F'                    05568
         DC    XL16'909192939495969798999A9B9C9D9E9F'                    05569
         DC    XL16'A0A14AB19FB26AB5BBB4AAABB0ADAFBC'                    05570
         DC    XL16'B08FB2B3BEA0B6B39DB99BB8B7B8B9AB'                    05571
         DC    XL16'C0C1C2C3C4C59EC7C8C9CACBCCCDCECF'                    05572
         DC    XL16'ACD1D2D3D4D5D6BFD8D9DADBDCDDAEDF'                    05573
         DC    XL16'E0E1E2E3E4E59CE7E8E9EAEBECEDEEEF'                    05574
         DC    XL16'8CF1F2F3F4F5F6E1F8F9FAFBFC8D8EFF'                    05575
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
SCNSYSIN DS    0H                 Routine to extract info from SYSIN.
         ST    R9,SAVER9SC
* -------------- >>>>>>   Look for SYSIN cards            - BELOW
         TM    FLAGSYST,X'08'       Is SYSIN there?
         BZ    SCNSYSIE             No. Then can't open it. So get out.
         OPEN  (SYSIN,(INPUT))
SYSINLUP DS    0H
         GET   SYSIN,GETSYSIN
         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?
         BE    SYSNWVOL              Yes. Go process the new volume.
         CLC   =C'CHUNKSIZE=',GETSYSIN     Changing the chunk size?
         BE    SYSCHUNK                    Looks that way.....
         CLC   =C'READ ',GETSYSIN
         BE    SYSREAD
         CLC   =C'IDRCOFF ',GETSYSIN
         BE    SYSIDRCO
         B     SYSINLUP              Look for another card.
SYSNWVOL DS    0H
         CLI   GETSYSIN+7,C' '       Is the next letter a blank?
         BE    SYSINLUP              Yes. Ignore this card.
         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.
         B     SYSINLUP
SYSCHUNK DS    0H
         CLI   GETSYSIN+10,C' '  Is the first number value blank?
         BE    SYSINLUP          Yes. Ignore entire card.
         CLI   GETSYSIN+10,X'F0' Smaller than zero?
         BL    SYSINLUP          Yes. Get another card.
         CLI   GETSYSIN+10,X'F9' Bigger than X'F9' (number 9)?
         BH    SYSINLUP          Yes. Get another card.
         OI    FLAGCHNK,X'01'    Show chunk size default was changed.
         LA    R15,GETSYSIN+10   Now get the number that was coded.
         LR    R1,R15            Load R1 with beginning of the number.
SYSCHNUM DS    0H
         LA    R15,1(,R15)       Bump to next character.
         C     R15,=A(GETSYSIN+71)  End of SYSIN card yet?
         BH    SYSCHGNM          Yes. Go get the number.
         CLI   0(R15),C' '       Not end of card. But is it a blank?
         BE    SYSCHGNM          Yes. Then get the number.
         B     SYSCHNUM          Not a blank yet. Step up one place.
SYSCHGNM DS    0H
         SR    R15,R1            How many digits is the number?
         BCTR  R15,0             Lower it by one for EXECUTE.
         EX    R15,PACK          Copy the number to work area.
         CVB   R0,WORKA          Convert it to a binary number.
         ST    R0,CHNKSIZE       And store the value for later use.
         L     R0,=F'&DEFCHNK'   >>> Force 65535 chunk size.
         ST    R0,CHNKSIZE       >>> X'FFFF' is the only possibility.
SYSCHCLG DS    0H
         B     SYSINLUP          Go look for another card.
SYSREAD  DS    0H
         OI    READFLAG,X'01'
         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.
         B     SYSINLUP
SYSIDRCO DS    0H
         OI    IDRCFLAG,X'01'
         B     SYSINLUP
SYSINEND DS    0H                No more cards. Close SYSIN DCB.
         CLOSE SYSIN
* -------------- >>>>>>   Look for SYSIN cards            - ABOVE
SCNSYSIE DS    0H
         L     R9,SAVER9SC
         BR    R9
* - - >
PACK     PACK  WORKA,0(0,1)          <<< EXECUTED >>>
WORKA    DC    D'0'
* - - >
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
*     Routine to read a block of data from the input tape and
*     save byte counts from it, to make the FAKETAPE headers.
* ----------------------------------------------------------------- *
READBLOK DS    0H
         ST    R9,SAVER9RB        Save BAL register
         ST    R2,SAVER2R         Store work registers
         ST    R3,SAVER3R
         MVC   INECB,=F'0'        Initialize IN's ECB
         EXCP  INIOB              Read
         WAIT  ECB=INECB          Wait for Read
         TM    INCSW+4,X'01'      Was TM Read?
         BO    READTPMK           Yes
         CLI   INECB,X'7F'        Did Read complete normally?
         BNE   INERR              No -- error
         ZAP   TPMKCNT,=P'0'      Not a tape mark. Zero running count.
         AP    BLOCKCNT,=P'1'
         AP    BLOCKTOT,=P'1'
         NI    TPMKFLAG,X'FF'-X'01'    Set that Tape Mark was not read
         XC    FULLWORK,FULLWORK   Clear area completely
         MVC   HALFWORK(2),INCCW+6   Read length
         L     R2,FULLWORK           Load R2 with full low order
         MVC   HALFWORK(2),INCSW+6   Residual byte count
         L     R3,FULLWORK           Load R3 with full low order
         SR    R2,R3              R2=Actual length read
         STH   R2,BYTESCOP        Save quantity of bytes copied
         MVC   CURRBYTE(2),BYTESCOP     Save byte count of this block
         NI    ISLBLFLG,X'FF'-X'01'  Turn off "IS LABEL" flag
         OI    NWBLKFLG,X'01'        Turn on "new block" flag
         B     READNOTM           This READ was not a Tape Mark
*
READTPMK DS    0H                 This READ was a Tape Mark
         TM    TPMKFLAG,X'01'     Check if there was another TM before
         BZ    READTFST           No. First one.
         OI    TPMKFLAG,X'02'     If two in a row, flag that situation
READTFST DS    0H
         TM    TPMKFLAG,X'02'     Second Tape Mark in a row?
*
* --- >                           Null SL file is not EOT - below
         BNO   NOFIN1               Not 2 T.M. in a row. Go on.
         TM    FLAGHDRL,X'01'       Test if HDR label was last seen
         BO    NOFIN0               Yes. Must be null SL file.
         B     FIN                  Otherwise, valid 2 TMs and EOT.
NOFIN0   DS    0H
         NI    ISLBLFLG,FF-X'01'  This is data, can't be a label.
NOFIN1   DS    0H
* --- >                           Null SL file is not EOT - above
*
         AP    FILCOUNT,=P'1'     Add 1 to File Count.
         OI    TPMKFLAG,X'01'     Tell that we read a Tape Mark.
         MVC   CURRBYTE(2),=X'0000'  Show that next count is zero.
READNOTM DS    0H
* ---->     for the trace            All READ results should come here
         MVC   LINE,LINE-1           Clear output line
         MVC   LINE+1(16),READTRMS   Put in Read Trace message
         TM    TPMKFLAG,X'01'        Was last READ a Tape Mark?
         BZ    ITSABLOC              No. Mark trace as for a block.
         MVC   LINE+13(4),=C'TPMK'   Yes. Mark trace for a Tape Mark.
         B     ITSATPMK              And go farther.
ITSABLOC DS    0H
         MVC   LINE+13(4),=C'BLOC'   Show this trace was for a block
ITSATPMK DS    0H
         HEX   LINE+20,2,BYTESCOP    Show BYTES Copied field from READ
         HEX   LINE+26,2,CURRBYTE    Show Curr Bytes field for Header
         HEX   LINE+32,2,LASTBYTE    Show Prev Bytes field for Header
         HEX   LINE+37,1,TPMKFLAG    Trace Tape Mark Flag
         HEX   LINE+40,12,HEADER     Show the Header last constructed
         HEX   LINE+68,30,INAREA     Show first 20 bytes of Input Area
         TM    FLAGSYST,X'01'        Is SYSTRACE ddname present?
         BNO   NOREADT1              No. Can't print trace line.
         PUT   SYSTRACE,LINE
NOREADT1 DS    0H                    Trace is finished.
* ---->     for the trace
         L     R2,SAVER2R         Restore work registers
         L     R3,SAVER3R
         B     READBEND           and exit normally.
* -----
INERR    DS    0H                 READ error on input tape
         MVC   LINE,LINE-1        Clear print line
         TM    INCSW+4,X'02'      Unit Check?
         BZ    INERR1             No - Assume Data Check
         MVC   LINE(133),INEQC    Set Error Message
         B     INERR2             Continue
INERR1   MVC   LINE(133),INDCK    Set Error Message
INERR2   PUT   SYSPRINT,LINE      Write Error Message
         L     R2,SAVER2R         Restore work registers
         L     R3,SAVER3R         Rewind the tape, and exit.
         MVC   INCCWPT(4),=A(RUNCCW)   Get set to Rewind and Unload
         MVC   INECB,=F'0'        Initialize IN's ECB
         EXCP  INIOB              Rewind and Unload
         WAIT  ECB=INECB          Wait for Rewind and Unload
         B     WRITSUMM           Write summary of what was done,
*                                  and get out of the program.
READBEND DS    0H
         L     R9,SAVER9RB        Restore BAL register
         BR    R9
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
MAKEHEDR DS    0H
         ST    R9,SAVER9MH
* ----------------------------------------------------------------- *
*     We are forming the new header in the field HEADER.
*     We assume that the TAPEREAD subroutine was executed first.
*     We assume that the FLDAREA was previously saved to SAVAREA.
* ----------------------------------------------------------------- *
         MVC   HEADER(12),BLNKHEDR     Start fresh.
         MVC   HDRPRVLN(2),LASTBYTE    Always HDRCURLN from last header
         MVC   HDRNSTOR(2),CURRBYTE
         MVC   HDRCURLN(2),HDRNSTOR    And copy into HDRCURLN spot
MAKEWHAT DS    0H                      Manufacture the proper hdr flags
         TM    TPMKFLAG,X'01'          Has a tape mark been read?
         BO    MAKETPMH                First test. Make a X'40' header
         B     MAKEFAKE
MAKETPMH DS    0H                      Tape mark has been read.
         MVC   HDRCURLN(2),=X'0000'    Next header is right after this.
MAKEFAKE DS    0H
         MVC   HDRCHKWK(2),HDRPRVLN    Create header check field
         XC    HDRCHKWK(2),HDRCURLN    XOR prev with curr
* --                                   Convert quantities to ASCII
         LA    R1,HDRPRVLN             Previous bytes in binary
         BAL   R9,ASCCNVRT             Convert to ASCII numbers
         MVC   HDRFKPRV(4),ASCWORK     Stuff into header field
         LA    R1,HDRCURLN             Current bytes in binary
         BAL   R9,ASCCNVRT             Convert to ASCII numbers
         MVC   HDRFKNXT(4),ASCWORK     Stuff into header field
         LA    R1,HDRCHKWK             XOR of both of them
         BAL   R9,ASCCNVRT             Convert to ASCII numbers
         MVC   HDRFKCHK(4),ASCWORK     Stuff into header field
* --                                   The header is now created
         MVC   HEADEREB(12),HEADER     Move copy of header to wkarea
         TR    HEADEREB(12),TRTA2E     Translate into EBCDIC for print
MAKEHDEN DS    0H
         MVC   LASTBYTE,HDRCURLN       Store to insert in next HDRPRVLN
         AP    OUTHDRS,=P'1'           Count this header we've made.
*----------------------------------------------------------------- *
*   Now that we've made a header, we do a display.
*----------------------------------------------------------------- *
*
KINDAHEN DS    0H
         CLC   HDRFKNXT,=X'30303030'
         BNE   BLOKHEDR
         AP    OUTTYPE2,=P'1'
         B     NOTBLOKH
BLOKHEDR DS    0H
         AP    OUTTYPE1,=P'1'
NOTBLOKH DS    0H
         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?
         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION
         MVC   OUTLINE,OUTLINE-1      CLEAR PRINT LINE
         MVC   OUTLINE+2(4),=C'hdr:'
         MVC   OUTLINE+8(12),HEADEREB   EBCDIC REPRESENTATION OF HEADER
         HEX   OUTLINE+28,4,FLDSCARD                            .
         HEX   OUTLINE+38,4,FLDECARD                            .
         HEX   OUTLINE+48,4,FLDOFFST                            .
         HEX   OUTLINE+58,4,FLDBYTES                            .
         HEX   OUTLINE+68,4,FLDBYTOT                            .
         HEX   OUTLINE+78,4,FLDBYMVD                            .
         HEX   OUTLINE+88,4,FLDBUFFR                            .
         HEX   OUTLINE+98,4,FLDBSTRT                            .
         HEX   OUTLINE+108,7,FLDOUTCT                           .
         HEX   OUTLINE+124,1,FLDREADF
         PUT   SYSTRACE,OUTLINE
NOSYSTR1 DS    0H
MAKEHEND DS    0H
         L     R9,SAVER9MH
         BR    R9
* ----------------------------------------------------------------- *
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
*                                                           *
*    FOLDBUFF ROUTINE  -  CALL TO FOLDEM SUBPROGRAM         *
*                                                           *
*    All FLDAREA field required for call have to be         *
*    filled in:                                             *
*                                                           *
*    FLDSCARD - Initialized to OUTCARD at beg of program    *
*    FLDECARD - Initialized to OUTCARD+80                   *
*    FLDOFFST - Initialized to 0, updated by each call      *
*    FLDBYTES - Set before each call                        *
*    FLDBYTOT - Set before each call                        *
*    FLDBYMVD - Calculated by FOLDEM, caller reinitializes  *
*    FLDBUFFR - Initialized to buffer, updated by FOLDEM    *
*    FLDBSTRT - Start of input buffer                       *
*    FLDOUTCT - Initialized to P'0', updated by FOLDEM      *
*    FLDREADF - READFLAG, copied into FLDAREA control blk   *
*                                                           *
* --------------------------------------------------------- *
FOLDBUFF DS    0H
         ST    R9,SAVER9FB              Save BAL register
         MVC   LINE,LINE-1
*        MVC   LINE+1(8),=C'BEFCALL-'   Diagnostic picture before call
*        BAL   R9,FLDIMAGE
         LA    R1,FLDAREA
         L     R15,=V(FOLDEM)           Entry point of FOLDEM program
         BALR  R14,R15                  Call it.
*                                       Copy back FLDAREA from FOLDEM
         ST    R1,NEWFLDA               Save new FLDAREA address
         MVC   FLDAREA(FLDLENTH),0(R1)  Overlay new FLDAREA over ours
         MVC   LINE,LINE-1
*        MVC   LINE+1(8),=C'AFTCALL-'   Diagnostic picture after call
*        BAL   R9,FLDIMAGE
FOLDBUFE DS    0H
         L     R9,SAVER9FB              Restore BAL register
         BR    R9                       Return to caller
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
* --------------------------------------------------------- *
FLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently
*
         ST    R9,SAVER9FI
         HEX   LINE+10,4,FLDSCARD
         HEX   LINE+20,4,FLDECARD
         HEX   LINE+30,4,FLDOFFST
         HEX   LINE+40,4,FLDBYTES
         HEX   LINE+50,4,FLDBYTOT
         HEX   LINE+60,4,FLDBYMVD
         HEX   LINE+70,4,FLDBUFFR
         HEX   LINE+80,4,FLDBSTRT
         HEX   LINE+90,7,FLDOUTCT
         HEX   LINE+106,1,FLDREADF
         PUT   SYSPRINT,LINE
         MVC   LINE,LINE-1
         L     R9,SAVER9FI
         BR    R9
* --------------------------------------------------------- *
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ
*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED
* --------------------------------------------------------- *
ADDCOUNT DS    0H                  ADD BYTE COUNT SUBROUTINE
         ST    R9,SAVER9AD         Save BAL register
         STM   R4,R5,SAVEADDC      Save work registers
         L     R4,0(,R3)           Load high order counter
         L     R5,4(,R3)           Load low order counter
         AR    R5,R2               Add to byte count
         BNO   ADDCNOOV            No overflow, then branch
         LA    R4,1(,R4)           else, overflow to high word
         X     R5,=X'7FFFFFFF'     Get rid of sign bit
ADDCNOOV DS    0H
         ST    R4,0(,R3)           Put updated counter in storage
         ST    R5,4(,R3)           Put updated counter in storage
         LM    R4,R5,SAVEADDC      Restore work registers
ADDCOUNE DS    0H                  END OF ROUTINE - RETURN
         L     R9,SAVER9AD         Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
LABELCHK DS    0H         Check for the presence of tape labels
*                         and set label flags, accordingly,
*                         in the LBLFLAG byte.
*
*              X'01'    HDR1 HAS BEEN SEEN
*              X'02'    HDR2 HAS BEEN SEEN
*              X'04'    VOL1 HAS BEEN SEEN
*              X'08'    HDR1 IS FROM AN INITTED TAPE
*              X'10'    EOF1 HAS BEEN SEEN
*              X'20'    EOF2 HAS BEEN SEEN
*              X'40'    EOV1 HAS BEEN SEEN
*              X'80'    EOV2 HAS BEEN SEEN
*
* --------------------------------------------------------- *
         ST    R9,SAVER9LB          Save BAL register
         NI    ISLBLFLG,FF-X'01'    Turn off "Is Label" flag at start
         CLC   INAREA(4),=C'VOL1'   Is this a VOL1 ?
         BE    CVOL1                Process THE VOL1
         CLC   INAREA(4),=C'HDR1'   Is this a HDR1 ?
         BE    CHDR1                Process HDR1
         CLC   INAREA(4),=C'HDR2'   This a HDR2 ?
         BE    CHDR2                Process HDR2
         CLC   INAREA(4),=C'EOF1'   This an EOF1 ?
         BE    CEOF1                Process EOF1
         CLC   INAREA(4),=C'EOF2'   This an EOF2 ?
         BE    CEOF2                Process EOF2
         CLC   INAREA(4),=C'EOV1'   This an EOV1 ?
         BE    CEOV1                Process EOV1
         CLC   INAREA(4),=C'EOV2'   This an EOV2 ?
         BE    CEOV2                Process EOV2
         CLC   INAREA(3),=C'UHL'    This a User Header Label?
         BE    CUHL                 Process UHL
         CLC   INAREA(3),=C'UTL'    This a User Trailer Label?
         BE    CUTL                 Process UTL
         B     NOTLABEL             80 byte record is not an IBM SL
*        ------------------------------------------------------ *
CVOL1    DS    0H                   PROCESS VOL1 LABEL
* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRCV             NO. SKIP ROUTINE.
         MVI   INAREA+35,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRCV DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  ABOVE
         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
* ----- >    CHANGE OUTPUT VOLUME NAME - below
         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?
         BE    NOCHGVOL                  YES. DON'T CHANGE.
         LA    R1,INAREA                 Point to INAREA
         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.
         MVC   MESSAG13+30(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.
         PUT   SYSPRINT,MESSAG13         VOLSER overridden message.
         TM    FLAGSYST,X'02'
         BZ    NCHGMOVD
         PUT   SYSMOVED,MESSAG13
NCHGMOVD DS    0H
         TM    FLAGSYST,X'04'            SYSFILES here?
         BZ    NCHGFILE                  Nope. Skip a PUT to it.
         PUT   SYSFILES,MESSAG13         VOLSER overridden message.
         MVC   OUTLINE,OUTLINE-1         Blank line to separate
         PUT   SYSFILES,OUTLINE             from the rest of output.
NCHGFILE DS    0H
NOCHGVOL DS    0H                        Kludge extra blank like
         TM    FLAGSYST,X'04'            Is SYSFILES here?
         BZ    KLUDGE01                  Nope. No PUTs to it.
         CLC   SVNEWVOL(6),=C'      '    VOLSER not being overridden?
         BNE   KLUDGE01                  Is overridden, no extra blank.
         MVC   OUTLINE,OUTLINE-1         Not overridden. Kludge a blank
         PUT   SYSFILES,OUTLINE
KLUDGE01 DS    0H
* ----- >    CHANGE OUTPUT VOLUME NAME - above
         B     LABCHEND
CHDR1    DS    0H
         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS
         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.
         CLC   INAREA+4(23),ZERO23  WAS TAPE INITTED?
         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET
         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE
CHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CHDR2    DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRH2             NO. SKIP ROUTINE.
         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?
         BNE   CLRIDRH2
         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRH2 DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  ABOVE
         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2
         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOF1    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1
         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOF2    DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRF2             NO. SKIP ROUTINE.
         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?
         BNE   CLRIDRF2
         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRF2 DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  ABOVE
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2
         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOV1    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1
         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOV2    DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRv2             NO. SKIP ROUTINE.
         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?
         BNE   CLRIDRV2
         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRV2 DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  ABOVE
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2
         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *
CUHL     DS    0H                   HANDLE USER HEADER LABELS
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CUTL     DS    0H                   HANDLE USER TRAILER LABELS
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *
NOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF "IS LABEL" FLAG
LABCHEND DS    0H                   Return to caller
         L     R9,SAVER9LB          Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
SUMMREPT DS    0H                        Write Summary Totals
         ST    R9,SAVER9SR               Save BAL Register
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG01
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),FLDOUTCT   NUMBER OF INPUT RECORDS READ
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG02
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTHDRS    NUMBER OF HEADERS ENCOUNTERED
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG03
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE1   BEGINNING OF BLOCK HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG06
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE2   END OF BLOCK HEADERS
         PUT   SYSPRINT,OUTLINE
* >---->                                 Display tape total counts
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG03       Total bytes folded for tape
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTMH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31               MULT BY 2 TO THE 31ST
         L     R4,DBOUTML                LOAD REG WITH LOW ORDER
         CVD   R4,DWORD                  CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD               AND ADD IT IN
         ED    FILEBYTE,QWORD+6          DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM01
         PUT   SYSFILES,CNTLINE
NOSUMM01 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG04       Total bytes read for tape
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTL          LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM02
         PUT   SYSFILES,CNTLINE
NOSUMM02 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG05       Total bytes read for labels
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,LBINH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,LBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM03
         PUT   SYSFILES,CNTLINE
NOSUMM03 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG06       Total bytes read for data
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DAINH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DAINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM04
         PUT   SYSFILES,CNTLINE
NOSUMM04 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG08       Total blocks read for tape
         MVC   FILEBYTE,BYTESPAT
         MVC   CNTLINE+54(11),BLOKPAT
         ED    CNTLINE+54(11),BLOCKTOT+2
         MVC   CNTLINE+65(6),=C'Blocks'
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM05
         PUT   SYSFILES,CNTLINE
NOSUMM05 DS    0H
* >---->
SUMMREND DS    0H                  END OF ROUTINE - RETURN
         L     R9,SAVER9SR         Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
REPTFILE DS    0H       Routine to write block and byte counts
*                       for each file in the SYSFILES ddname.
* --------------------------------------------------------- *
*----------->>
         ST    R9,SAVER9RF
*--->                   Block counts first  -  below
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG07
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   CNTLINE+54(11),BLOKPAT
         ED    CNTLINE+54(11),BLOCKCNT+2
         MVC   CNTLINE+65(6),=C'Blocks'
         MVC   CNTLINE+90(11),BLOKPAT
         ED    CNTLINE+90(11),BLOCKTOT+2
         MVC   CNTLINE+102(10),=C'Cum Blocks'
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE00
         PUT   SYSFILES,CNTLINE
NOFILE00 DS    0H
* >---->
*--->                   Block counts first  -  above
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG01
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTFMH        Bytes folded counts for this file
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTFML        LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
* >--->
         TM    ISLBLFLG,X'01'
         BO    DISLABLS
         MVC   DATBYTES,BYTESPAT
         L     R4,DAINH           Data bytes written cumulative to here
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DAINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(38),DATDISPL
         B     DISPDATA
* >--->
DISLABLS DS    0H
         MVC   LABBYTES,BYTESPAT
         L     R4,LBINH           Label bytes written, cumulative
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,LBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(38),LABDISPL
         B     DISPDATA
* >--->
DISPDATA DS    0H
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE01
         PUT   SYSFILES,CNTLINE
NOFILE01 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG02
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTFH         Bytes written for this file
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTFL         LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
* >--->
         CLC   DBOUTF(8),DBOUTFM
         BE    RIGHTBYT
         MVI   CNTLINE+72,C'*'
RIGHTBYT DS    0H
* >--->
         MVC   CUMBYTES,BYTESPAT
         L     R4,DBOUTH          Bytes written, cumulative
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTL          LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(43),CUMDISPL
* >--->
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE02
         PUT   SYSFILES,CNTLINE
NOFILE02 DS    0H
         L     R4,SAVER4Q
         MVC   CNTLINE,CNTLINE-1
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE03
         PUT   SYSFILES,CNTLINE
NOFILE03 DS    0H
*----------->>
REPTFEND DS    0H
         L     R9,SAVER9RF
         BR    R9
         EJECT
* ----------------------------------------------------------------- *
*      CCWs and IOB for the EXCP operations.
* ----------------------------------------------------------------- *
*              read,addr of data,flags,64K bytes
RUNCCW   DC    X'0F',AL3(INAREA),X'6000',X'0000'     Rewind Unload CCW
         DC    X'03',AL3(INAREA),X'2000',X'0000'     NOP CCW
INCCW    DC    X'02',AL3(INAREA),X'2000',X'FFFF'     Read CCW
INECB    DC    F'0'
INIOB    DC    X'02000000'
         DC    A(INECB)
INCSW    DC    2F'0'
INCCWPT  DC    A(INCCW)
INDCBPT  DC    A(TAPIN)
         DC    F'0'
         DC    X'00010000'
         DC    XL44'00'            Padding
         SPACE 3
* ----------------------------------------------------------------- *
         ENTRY FAKEOUT
FAKEOUT  DCB   DDNAME=FAKEOUT,MACRF=PM,DSORG=PS,LRECL=80
TAPIN    DCB   MACRF=(E),DDNAME=TAPIN,DEVD=TA,DSORG=PS,RECFM=U
         ENTRY SYSPRINT
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X
               EODAD=SYSINEND
         DC    CL8' '
FF       EQU   X'FF'
BLNKHEDR DC    XL12'303030303030303030303030'
* ----------------------------------------------------------------- *
*
* AWSTAPE BLOCK HEADER
*
* ----------------------------------------------------------------- *
HEADER   DS    0CL12                    BLOCK HEADER
HDRFKPRV DC    XL4'30303030'
HDRFKNXT DC    XL4'30303030'
HDRFKCHK DC    XL4'30303030'
* --- >
HDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH
HDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH
HDRCHKWK DC    XL2'0000'                XOR CHECK WORK AREA
* --- >
*
         DC    XL80'00'                 PADDING
HEADEREB DS    XL12
* ----------------------------------------------------------------- *
         DC    XL12'00'                 PADDING
HALFZERO DC    XL2'00'
         DC    XL12'00'                 PADDING
HDRNSTOR DC    XL2'00'             STORE BYTES IN NEXT BLOCK - BIF
HDRPSTOR DC    XL2'00'             STORE BYTES IN PREV BLOCK - BIF
         DC    XL12'00'                 PADDING
BYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT
CURRBFUL DS    0F
         DC    H'0'
CURRBYTE DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT
LASTBFUL DS    0F
         DC    H'0'
LASTBYTE DC    H'0'           LAST NUMBER OF BYTES COPIED FROM INPUT
PARTBFUL DS    0F
         DC    H'0'
PARTBYTE DC    H'0'           PARTIAL LAST BYTES ON CHUNKED INPUT
ZEROCARD DC    80X'30'
* -------------------------------------------- *
* ---------- *      F L A G S     * ---------- *
* -------------------------------------------- *
* ---------- *
READFLAG DC    X'00'         This run is "READ ONLY"  ?
*              X'01'         Yes, read only.
* ---------- *
NWBLKFLG DC    X'00'         We have just read a new block.
*              X'01'         Turned off after first chunk write.
* ---------- *
IDRCFLAG DC    X'00'         This run is "IDRC Fix"  ?
*              X'01'         Turn off IDRC indicator
* ---------- *
FLAGCHNK DC    X'00'          FLAG TO SHOW IF CHUNK SIZE WAS CODED
*              X'01'          CHUNK SIZE IS NOT BLANK
* ---------- *
FLAGSYST DC    X'00'          FLAG TO SHOW IF OPTIONAL DD'S THERE
*              X'01'          //SYSTRACE DD IS THERE
*              X'02'          //SYSMOVED DD IS THERE
*              X'04'          //SYSFILES DD IS THERE
*              X'08'          //SYSIN    DD IS THERE
* ---------- *
CHNKFLAG DC    X'00'          ARE WE CHUNKING THE BLOCKS?
*              X'01'          BUFFER BYTES BIGGER THAN CHUNK SIZE
* ---------- *
BUFINISH DC    X'00'          Have we finished folding entire buffer?
*              X'01'          Yes. We are now finishing the buffer.
* ---------- *
LBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN
*              X'01'    HDR1 HAS BEEN SEEN
*              X'02'    HDR2 HAS BEEN SEEN
*              X'04'    VOL1 HAS BEEN SEEN
*              X'08'    HDR1 IS FROM AN INITTED TAPE
*              X'10'    EOF1 HAS BEEN SEEN
*              X'20'    EOF2 HAS BEEN SEEN
*              X'40'    EOV1 HAS BEEN SEEN
*              X'80'    EOV2 HAS BEEN SEEN
* ---------- *
ISLBLFLG DC    X'00'          FLAG INDICATING WE JUST READ A LABEL
*              X'00'          DATA IS NOT A LABEL
*              X'01'          DATA IS A LABEL
* ---------- *
TPMKFLAG DC    X'00'          Flag that we encountered a Tape Mark
*              X'01'          We just read a Tape Mark
*              X'02'          We previously read a Tape Mark
* ---------- *
FLAGHDRL DC    X'00'          Header label flag - Last label was a hdr
*              X'01'          EOT HEADER is following a HDR1 or HDR2
* ---------- *
* -------------------------------------------- *
FULLWORK DS    0F
FULLHIGH DC    H'0'
HALFWORK DC    H'0'                HALFWORD WORK AREA
         DC    2F'0'               Padding
FOLDBREG DS    0F                  Fullword - no of bytes to fold
FOLDHIGH DC    XL2'00'             High order - should be zeros
HDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD
HDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD
HDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED
HDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD
HDRPRVF  DC    XL2'00'
HDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED
HDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD
HDRLENFL DC    XL2'00'
HDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER
HDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD
HDRPRVFL DC    XL2'00'
HDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER
OUTCCWST DC    XL2'00'
         DC    XL2'00'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         MVC   1(1,R15),0(R1)      MOVE BYTE
         UNPK  0(3,R15),1(2,R15)   UNPACK
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         INCREMENT OUTPUT PTR
         LA    R1,1(,R1)           INCREMENT INPUT PTR
         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP
         MVI   0(R15),C' '         BLANK THE TRAILING BYTE
         BR    R4                  RETURN TO CALLER
HEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
SVNEWVOL DC    CL6' '              SAVED NEW VOLUME
CHNKSIZE DC    F'65535'            Default is maximum halfword
LASTLINE DS    0CL80
LASTHX00 DC    80X'00'
HEXSAVE  DS    3F                  SAVE FOR HEX MACRO
DWORD    DC    D'0'
QWORD    DS    PL16
TWO31    DC    P'2147483648'       2 TO THE 31ST
OUTHDRS  DC    PL7'0'
OUTTYPE1 DC    PL7'0'
OUTTYPE2 DC    PL7'0'
OUTTYPE3 DC    PL7'0'
OUTTYPE4 DC    PL7'0'
OUTTYPE5 DC    PL7'0'
FILCOUNT DC    PL7'0'
BLOCKCNT DC    PL7'0'
BLOCKTOT DC    PL7'0'
TPMKCNT  DC    PL7'0'
DECVALUE DS    CL8
FILEPAT  DC    X'402020202020202120'
BLOKPAT  DC    X'4020202020202020212020'
EDPAT    DC    X'40206B2020206B2020206B2020206B202120'
BYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'
FILEBYT  DS    0CL32
FILEBYTE DC    C' 9,999,999,999,999,999,999'
         DC    C' Bytes'
CUMDISPL DS    0CL43
CUMBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Total Bytes'
LABDISPL DS    0CL38
LABBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Labels'
DATDISPL DS    0CL38
DATBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Data  '
*
SVBEGCRD DS    F
SVENDCRD DS    F
SVBFAREA DS    F                Address of input buffer
*
SAVER2R  DS    F                Save work regs during tape read.
SAVER3R  DS    F                Save work regs during tape read.
SAVER4B  DS    F                Register Save for HEX routine
SAVER4Q  DS    F                Register Save for byte count reperting
SAVEFOLD DS    6F               Register Save for FOLDEM routine
SAVEADDC DS    3F               Register Save for ADDCOUNT routine
SAVEMOVE DS    3F               REGISTER SAVE FOR FOLDEM ROUTINE
SAVER9AD DS    F                Register Save for ADDCOUNT routine
SAVER9RB DS    F                Register Save for READBLOK routine
SAVER9RF DS    F                Register Save for REPTFILE routine
SAVER9LB DS    F                Register Save for LABELCHK routine
SAVER9SR DS    F                Register Save for SUMMREPT routine
SAVER9FB DS    F                Register Save for FOLDBUFF routine
SAVER9FI DS    F                Register Save for FLDIMAGE routine
SAVER9SC DS    F                Register Save for SCNSYSIN routine
SAVER9MH DS    F                Register Save for MAKEHEDR routine
SAVER9AC DS    F                Register Save for ASCCNVRT routine
NEWFLDA  DS    F
HDRSIZE  DC    F'12'            SIZE OF A HEADER
SVBEGDAT DS    F
*  -----------------
ZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1
*  -----------------     JFCB if we'll need RDJFCB later - not used now
JFCB1    DC    X'87'
         DC    AL3(INFMJFCB)
         IEFJFCBN LIST=YES
         DC    C' '
*
*  -----------------            Summary Totals Message Texts
PRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS OUT: '
PRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS OUT: '
PRMSG03  DC    CL34'     TOTAL BLOCK HEADERS        : '
PRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS    : '
PRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS    : '
PRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS  : '
PRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK  : '
*
*  -----------------            Byte Count Message Texts
CTMSG01  DC    CL38'     BYTES FOLDED FOR FILE:           '
CTMSG02  DC    CL38'     BYTES  READ  FOR FILE:           '
CTMSG03  DC    CL38'     TOTAL BYTES FOLDED FOR TAPE  :   '
CTMSG04  DC    CL38'     TOTAL BYTES  READ  FOR TAPE  :   '
CTMSG05  DC    CL38'     TOTAL BYTES  READ  FOR LABELS:   '
CTMSG06  DC    CL38'     TOTAL BYTES  READ  FOR DATA  :   '
CTMSG07  DC    CL38'     BLOCKS READ FOR  FILE:           '
CTMSG08  DC    CL38'     TOTAL BLOCKS READ  FOR TAPE  :   '
*
*  -----------------            Header Message Texts
MESSAGE1 DC    CL133'1VTT2T2FK - REAL TAPE TO FB-80 AWS CONVERSION PROG-
               RAM  '
MESSAGE2 DC    CL133'1VTT2T2FK  -  AWS TAPE HEADER TRACE REPORT  '
MESSAGE3 DC    CL133'1VTT2T2FK - TAPE TO AWS DATA MOVE - TRACE AND ERRO-
               R REPORT  '
MESSAGE4 DC    CL133'1VTT2T2FK - TAPE TO AWS FILE REPORT - READ AND FOL-
               D STATS  '
MESSAGE5 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -
               IS CREATED BY THE PROGRAM, IN MAKING AN AWS FORMAT TAPE.-
               '
MESSAGE6 DC    CL133'        THE FLDAREA (FOLDEM AREA CONTROL BLOCK) FI-
               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST FORMED.-
               '
MESSAGE7 DS    0CL133
         DC    CL8'  hdr:  '
         DC    CL12'HEADER TEXT '
         DC    CL1' '
         DC    CL4'TYPE'
         DC    CL3' '
         DC    CL10'FLDSCARD'
         DC    CL10'FLDECARD'
         DC    CL10'FLDOFFST'
         DC    CL10'FLDBYTES'
         DC    CL10'FLDBYTOT'
         DC    CL10'FLDBYMVD'
         DC    CL10'FLDBUFFR'
         DC    CL10'FLDBSTRT'
         DC    CL14'FLDINRCD'
         DC    CL11' '
MESSAGE8 DC    CL133'        IT IS APPROPRIATE THAT A TRACE BE TAKEN AT-
                EACH READ OF THE TAPE, AND ALSO WHEN THE HEADERS ARE MA-
               DE. '
MESSAGE9 DC    CL133'        AS OF RELEASE 1.12 OF VTT2T2FK, THE SYSMOV-
               ED REPORT IS NOT NECESSARY.  IF YOU NEED TRACE DATA NOW,-
                 '
MESSAG10 DC    CL133'        ENOUGH DATA IS AVAILABLE IN THE SYSTRACE R-
               EPORT.  BOTH "TAPE READ" AND "FOLD DATA" ARE AVAILABLE T-
               HERE.'
MESSAG11 DC    CL133'        IF YOU NEED ADDITIONAL TRACE DATA AND YOU -
               HAVE SOURCE CODE, THEN UNCOMMENT THE "BEFCALL-" AND "AFT-
               CALL-" '
MESSAG12 DC    CL133'        INVOCATIONS OF THE FLDIMAGE SUBROUTINE, WH-
               ICH ARE:  BAL   R9,FLDIMAGE  INSTRUCTION LINES.         -
                    '
MESSAG13 DC    CL133'    VOLSER Overridden to:    '
MESSAG14 DC    CL133'    Chunk Size is set to:    '
*  -----------------            Error Message Texts
ERRMESS1 DC    CL133'    OFFSET ERROR           '
INEQC    DC    C' *********** EQUIPMENT CHECK ON INPUT -- COPY '
         DC    C'TERMINATED '
         DC    76C'*'
INDCK    DC    C' ********** DATA CHECK ON INPUT -- COPY TERMINATED '
         DC    82C'*'
*  -----------------            Trace Message Texts
READTRMS DC    CL16'READ TRACE:     '
FOLDTRMS DC    CL16'FOLD TRACE:     '
MHDRTRMS DC    CL16'MAKEHEDR TRACE: '
OSETTRMS DC    CL16'OFFSET TRACE:   '
BBLKTRMS DC    CL16'BLOCK TRACE:    '
*    ------------------------ >   Output Line Buffers  -  below
         DC    C' '
CNTLINE  DC    CL133' '
         DC    C' '
OUTLINE  DC    CL133' '
         DC    C' '
LINE     DC    CL133' '           For error messages
         DC    C' '
PRTLINE  DC    CL133' '
         DC    C' '
MSGLINE1 DC    CL133' '           For READ only message
         DC    C' '
MSGLINE2 DC    CL133' '           For IDRC remove message
*    ------------------------ >   Output Line Buffers  -  above
         LTORG
SAVEHDR  DC    XL6'000000000000'
EOTMARK  DC    XL12'303030303030303030303030'
* - - - - >
*
FLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK
*                           ------ ---- ------- -----
FLDSCARD DC    F'0'         Start address of 80-byte card
FLDECARD DC    F'0'         End address of 80-byte card
FLDOFFST DC    F'0'         OFFSET of data in the card
FLDBYTES DC    F'0'         Number of bytes to be folded now
FLDBYTOT DC    F'0'         Batch total of bytes left to move
FLDBYMVD DC    F'0'         Number of bytes folded now
FLDBUFFR DC    F'0'         Current data start address
FLDBSTRT DC    F'0'         Original start data address
FLDOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records
FLDREADF DC    X'00'        This run is "READ ONLY"  ?
*              X'01'        Yes, read only.
FLDLENTH EQU   *-FLDAREA
*
* - - - - >
*         Saved Copy of FLDAREA Control Block
* - - - - >
*
SAVAREA  DS    0F           FOLDEM AREA CONTROL BLOCK
*                           ------ ---- ------- -----
SAVSCARD DC    F'0'         Start address of 80-byte card
SAVECARD DC    F'0'         End address of 80-byte card
SAVOFFST DC    F'0'         OFFSET of data in the card
SAVBYTES DC    F'0'         Number of bytes to be folded now
SAVBYTOT DC    F'0'         Batch total of bytes left to move
SAVBYMVD DC    F'0'         Number of bytes folded now
SAVBUFFR DC    F'0'         Current data start address
SAVBSTRT DC    F'0'         Original start data address
SAVOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records
SAVREADF DC    X'00'        This run is "READ ONLY"  ?
*              X'01'        Yes, read only.
SAVLENTH EQU   *-SAVAREA
*
* - - - - >
*    ------------------------ >   Byte Count Save Areas - below
*
*                          -- These are doubleword counters --
*
DBOUTF   DS    0D          BYTE COUNT SAVE AREA FOR INPUT FILE READ
DBOUTFH  DC    F'0'
DBOUTFL  DC    F'0'
DBOUTFM  DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE FOLDED
DBOUTFMH DC    F'0'
DBOUTFML DC    F'0'
DBOUT    DS    0D          BYTE COUNT SAVE AREA FOR INPUT TOTAL READ
DBOUTH   DC    F'0'
DBOUTL   DC    F'0'
DBOUTM   DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL FOLDED
DBOUTMH  DC    F'0'
DBOUTML  DC    F'0'
LBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES
LBINH    DC    F'0'
LBINL    DC    F'0'
DAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES
DAINH    DC    F'0'
DAINL    DC    F'0'
         DC    CL8' '      Extra padding for safety
*
*    ------------------------ >   Constants for Date and Time - below
SAVE1402 DS    6F                 ONE MORE FOR SAFETY
TIMED    DS    CL7
DATED    DS    CL9
DATETIME DS    4F
         ORG   DATETIME
TIME     DS    CL4
         DS    CL4
DATE     DS    CL5
         DS    CL3
HEADDLIT DS    0CL31              Literal for headings - date and time
         DC    CL6'Today:'
         DC    CL2' '
HEADDATE DC    CL23' '
LEVELLIT DS    0CL21              Level number display for headings
         DC    CL6'Level '
LEVELL   DC    CL4'&LLEV'
         DC    CL2' ('
LEVDATE  DC    CL8' '             Assembly date for this program
         DC    CL1')'
*    ------------------------ >   Constants for Date and Time - above
         DC    F'0'               Align, just for the heck of it
GETSYSIN DC    CL80' '
OUTCARDP DC    XL80'00'           Previous card-image read
OUTCARD  DC    XL80'00'           Current  card-image read
OUTCAEND EQU   *
         DC    XL80'00'           Room for another card-image
         DS    0F
         DC    CL8' '
INAREA   DS    CL65535            Buffer to hold tape blocks
         DS    CL800              Padding, so as not to overrun
*                                 somebody else's storage by mistake.
         END
   TITLE 'FOLDEM -- FOLD FB-80 DATA FROM A LONG BUFFER'
FOLDEM   CSECT
*  ---------------------------------------------------------------  *
*
*   AUTHOR:       Sam Golob
*
*   Copyright 2004 - 2005 by Sam Golob.  All rights reserved,
*                 subject to express permissions from the author
*                 to use this software.  This software is part
*                 of VTTS (Virtual Tape Transportation System).
*
*                 Permission is granted by the author for all
*                 parts of the VTTS package which are distributed
*                 on the CBT Tape collection, to be used by
*                 anyone for their own use, but not for resale
*                 or for reincorporation within commercial code.
*
*                           -------------------------------------
*                           It is probably not necessary to run
*                           this program in 24-bit mode.  But
*                           it works when it is run that way.
*                           -------------------------------------
*                           We do want old MVS systems to be able
*                           to run this routine.
*                           -------------------------------------
*
*  ---------------------------------------------------------------  *
*                                                                   *
*  SUBROUTINE:    FOLDEM                                            *
*                                                                   *
*  DESCRIPTION:                                                     *
*                                                                   *
*      This program is the heart of the process of creating an      *
*      FAKETAPE disk file from a real tape file.    The disk        *
*      file is data that has been folded over from a buffer,        *
*      into an FB-80 dataset.                                       *
*                                                                   *
*      This program takes buffer data and folds it into FB-80       *
*      data, starting from a given buffer address, for a given      *
*      number of bytes.  The data is folded into an 80-byte         *
*      workarea starting from a given OFFSET address (+0 to +79)    *
*      into the workarea.  When the workarea has been completely    *
*      filled and more data is to be written, a PUT is done to      *
*      write out the data from the 80-byte workarea, and then       *
*      the workarea is cleared with binary zeros before any         *
*      additional data is written to it.  An incompletely filled    *
*      workarea is not written out, and the same is true if the     *
*      workarea is full but no more data is to be written out.      *
*      So in that case, the location of the workarea is returned    *
*      to the caller in field FLDSCARD, and it is the caller's      *
*      responsibility to do the PUT for the last card.              *
*                                                                   *
*  INPUTS and OUTPUTS:                                              *
*                                                                   *
*      This program is driven by a control block called FLDAREA,    *
*      which is updated by both this program and by the caller.     *
*      See below for more details.                                  *
*                                                                   *
*  FILES NEEDED:                                                    *
*                                                                   *
*      This program assumes that the caller has opened DCBs for     *
*      an FB-80 file called FAKEOUT, which receives the output      *
*      "virtual tape" data, and for SYSPRINT.  This program         *
*      needs to do PUTs to FAKEOUT, and if necessary, it needs      *
*      to write messages to SYSPRINT.  Therefore the caller has     *
*      to provide ENTRY FAKEOUT and ENTRY SYSPRINT statements in    *
*      front of its FAKEOUT and SYSPRINT DCBs, respectively.        *
*                                                                   *
*  METHOD OF OPERATION:                                             *
*                                                                   *
*      This program operates using a control block, called the      *
*      FLDAREA, which is passed from the caller and back to the     *
*      caller.  Both the caller and this program update the         *
*      FLDAREA.  Upon entry to this program, R1 is expected to      *
*      point to the caller's copy of FLDAREA, and upon return,      *
*      R1 is pointed to the updated copy of FLDAREA in this         *
*      subroutine.  So the caller has to copy it back over its      *
*      own instance of FLDAREA after the return.                    *
*                                                                   *
*      The caller does one tape read, or read of data into a        *
*      buffer.  From the number of bytes read, the caller will      *
*      construct a FAKETAPE header which will determine how many    *
*      bytes should be folded into the FB-80 disk dataset.  This    *
*      FAKETAPE header is also folded by a call to this program,    *
*      and then the tape data is folded in afterward, for the       *
*      number of bytes required by the block size.                  *
*                                                                   *
*      This program does one or more PUTs into the FB-80 file,      *
*      until the request for the number of bytes to be folded,      *
*      is satisfied.  A PUT is done whenever the FB-80 work area    *
*      has been filled.  At the end of the fold operation, the new  *
*      OFFSET into the FB-80 workarea (that has not yet been        *
*      written out to disk), the number of bytes that have been     *
*      folded, and the projected start of the next data to be       *
*      folded, are returned in the fields of the FLDAREA control    *
*      block.                                                       *
*                                                                   *
*      The following is the layout of the FLDAREA.  Fields          *
*      marked with an arrow must be supplied upon input to this     *
*      program.                                                     *
*                                                                   *
*      FLDAREA  DS    0F         FOLDEM AREA CONTROL BLOCK          *
*      *                         ------ ---- ------- -----          *
*  --> FLDSCARD DC    F'0'       Start address of 80-byte card      *
*  --> FLDECARD DC    F'0'       End address of 80-byte card        *
*  --> FLDOFFST DC    F'0'       OFFSET of data in the card         *
*  --> FLDBYTES DC    F'0'       Number of bytes to be folded now   *
*  --> FLDBYTOT DC    F'0'       Batch total of bytes left to move  *
*      FLDBYMVD DC    F'0'       Number of bytes folded now         *
*  --> FLDBUFFR DC    F'0'       Current data start address         *
*  --> FLDBSTRT DC    F'0'       Original start data address        *
*      FLDOUTCT DC    PL7'0'     Number of PUTs for FAKEOUT records *
*  --> FLDREADF DC    X'00'      This run is "READ ONLY"  ?         *
*      *              X'01'      Yes, read only. (Copied from the   *
*                                READFLAG byte in the caller.)      *
*      FLDLENTH EQU   *-FLDAREA                                     *
*                                                                   *
*      The rest of the fields are calculated by this program        *
*      and returned to the caller.                                  *
*                                                                   *
*      FLDBUFFR and FLDOFFST are updated by this program, and       *
*      upon return to the caller, they point to the input data      *
*      and output data positions, respectively, that are just       *
*      after the moved data, to anticipate the next call, so as     *
*      to be able to move more data.  FLDBSTRT preserves the        *
*      very beginning address of the input buffer, whereas          *
*      FLDBUFFR is a place somewhere within the buffer, which       *
*      is the start from where the new data is expected to be       *
*      moved.                                                       *
*                                                                   *
*      A new field, FLDBYTOT, makes it possible to create           *
*      chunked blocks, but with FAKETAPE, that doesn't happen,      *
*      so we have set things up with chunksize always equal 65535   *
*      so "chunksize is always equal to blocksize".  The FLDBYTOT   *
*      field originally contains the number of bytes in an entire   *
*      block, and after the entire block has been written, it       *
*      should be decremented by the number of bytes written, and    *
*      it would therefore be 0.                                     *
*                                                                   *
*      Since both the caller and this program do PUT operations     *
*      to the output FB-80 file, the count of the number of PUTs    *
*      done, FLDOUTCT, is updated by BOTH the caller and by this    *
*      program.                                                     *
*                                                                   *
*  ---------------------------------------------------------------  *
         MACRO
*  ---------------------------------------------------------------  *
*    This macro is used to display hex values in a printed report.
*  ---------------------------------------------------------------  *
&NAME    HEX   &TO,&LEN,&FROM
&NAME    DS    0H
         ST    R4,SAVER04
         STM   15,1,HEXSAVE
         LA    1,&FROM
         LA    0,&LEN
         LA    15,&TO
         BAL   4,HEX
         L     R4,SAVER04
         LM    15,1,HEXSAVE
         MEND
         SPACE
         YREGS
FOLDEM   AMODE 24
FOLDEM   RMODE 24
         USING *,R15
         B     EYECATCH
         DC    C'--- '            MAKE EYECATCHER VISIBLE
         DC    C'FOLDEM'
         DC    C' - '
SYSDAT   DC    C'&SYSDATE'
         DC    C'  ',C'&SYSTIME '
SAVEAREA DC    18F'0'
EYECATCH DS    0D                    ENSURE ALIGNMENT
         STM   R14,R12,12(R13)
         LR    R5,R1                 SAVE PARM POINTER
         LA    R1,SAVEAREA           NEW SAVE-AREA ADDRESS
         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR
         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR
         LR    R13,R1                NEW SAVE AREA ADDRESS
         DROP  R15
* -----                              SET UP BASE REGISTERS
         USING FOLDEM,R12,R11
         LR    R12,R15
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LR    R1,R5                 RESTORE PARM POINTER
         ST    R1,SAVEPARM           Save pointer to caller's FLDAREA
         L     R0,SYSPRINV           SYSPRINT DCB address in caller
         ST    R0,SYSPRDCB             store for the program's use
         L     R0,FAKEOUTV           FAKEOUT  DCB address in caller
         ST    R0,FKOUTDCB             store for the program's use
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*                                                                   *
*   Routine to fold buffer data into an FB-80 file, starting at     *
*   a given location in the buffer, for a certain number of bytes,  *
*   and starting at a given OFFSET in the 80-byte workarea to       *
*   which the buffer data will be written.  When the 80-byte        *
*   workarea is filled up, a PUT is done to FAKEOUT, and the        *
*   workarea is cleared with binary zeros for more data to be       *
*   written.                                                        *
*                                                                   *
*   Input:   FLDAREA fields are all supplied by the calling         *
*            program, except for FLDBYMVD which is calculated       *
*            by this program and returned to the caller.  The       *
*            caller's copy of FLDAREA is pointed to by Register 1.  *
*                                                                   *
*            The buffer area containing the data to be folded       *
*            is supplied by the calling program, as well as the     *
*            number of bytes that is expected to be folded.         *
*                                                                   *
*   Output:  Data from the buffer will be moved into the 80-byte    *
*            workarea until the workarea is filled.  When the       *
*            workarea is filled, a PUT will be done to FAKEOUT,     *
*            and the workarea is cleared to X'00's to make room     *
*            for more data, when more data is to be written.        *
*                                                                   *
*            Ending OFFSET into the 80-byte workarea, pointing to   *
*            just after the data which has been moved, is returned  *
*            in the FLDOFFST field.  Upon return to the caller,     *
*            the FLDBUFFR field is updated to point to the place    *
*            in the buffer just after the data which has been       *
*            moved.  The FLDBSTRT field always should point to the  *
*            beginning of the data buffer, but this is at the       *
*            discretion of the calling program.                     *
*                                                                   *
*            A count of bytes actually moved from the buffer to     *
*            the 80-byte workarea (and written out by PUTs to the   *
*            FAKEOUT DD name as is necessary) is calculated by this *
*            program and returned in the FLDBYMVD field.  Upon      *
*            return, the number in the FLDBYMVD field should match  *
*            the number in the FLDBYTES field.                      *
*                                                                   *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* <--------- SET UP LOOP TO START MOVING THE DATA ------->
FOLDIT   DS    0H
         L     R1,SAVEPARM          Load address of caller's FLDAREA
         L     R2,=A(FLDBLOCK)      Load address of our copy of FLDAREA
         USING FLDBLOCK,R2
         MVC   FLDAREA(FLDLENTH),0(R1)  Move caller's FLDAREA to ours
* - - - - - - - - - -      Load the buffer quantities
         L     R7,FLDBUFFR          Initialize start of buffer data
         L     R8,FLDBYTES          Bytes to be moved
         AR    R8,R7                Add in start buffer address
         ST    R8,HYPOENDB          Hypothetical end-of-buffer address
*                                   which is probably the real
*                                   end-of-data to be moved.
* - - - - - - - - - -      Load the card quantities
         MVC   SAVEBEGC,FLDSCARD    Save "start of card" address
         MVC   SAVEENDC,FLDECARD    Save "end of card" address
         MVC   FLDBYMVD,=F'0'       Initialize count of bytes moved
         L     R7,FLDSCARD          Point to beginning of card
         A     R7,FLDOFFST          Add OFFSET to start of output
         ST    R7,SAVEBEGO          Save where output starts
         L     R8,SAVEBEGO          Copy beg of output address
         A     R8,FLDBYTES          Make hypothetical end address,
*                                   by adding the bytes to be moved.
         ST    R8,HYPOENDC          Store hypothetical card end address
*                                   (This may be way past end of card.)
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*  Cases:  1.  Current move is to within the current card.        *
*              Covered by LOOPSHRT routine.                       *
*                                                                 *
*          2.  Current move is past the current card.             *
*              Covered by LOOPMORE routine.  So we have to do     *
*              iterations.                                        *
*                                                                 *
*        R6 always contains the number of bytes to be moved       *
*        for this segment.                                        *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
LOOPINIT DS    0H
         L     R7,SAVEBEGO          Beginning of CARD data
         L     R8,HYPOENDC          Hypothetical end of CARD data
         L     R3,FLDBUFFR          Prime R3 with start of buffer data
         C     R8,SAVEENDC          Is R8 past the end-of-card?
         BH    LOOPMORE             Yes. Do multiple moves and PUTs.
LOOPSHRT DS    0H                   No. Do the one move only.
         LR    R6,R8                Get byte count to move NOW.
         SR    R6,R7                Bytes to move from buffer to card
         C     R6,=F'80'            More than 80?
         BH    LOOPERR1             Yes. Has to be error, so flag it.
         BCTR  R6,0                 No. One less for EXECUTE.
         EX    R6,MOVEBUFF          Move the data from buffer to card.
         LA    R6,1(,R6)            Restore count of bytes moved
         L     R1,FLDBYMVD          Increment
         AR    R1,R6                  total bytes moved.
         ST    R1,FLDBYMVD          Store it away for later.
         LA    R3,0(R6,R3)          Bop past beginning buffer address.
*        MVC   LINE+1(8),=C'LSHRT1: '   **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         C     R3,HYPOENDB          Not equal to predicted end?
         BNE   LOOPERR2             Error, so flag it.
         ST    R3,FLDBUFFR          Return modified new buffer address.
         LR    R6,R8                Calculate new OFFSET -
         S     R6,FLDSCARD          Subtract beginning of card address
         ST    R6,FLDOFFST          Store the result as new OFFSET
* -- >
LOOPTS50 DS    0H
*                                   If OFFSET > X'4F', card is complete
         C     R6,=F'80'            Is the new offset exactly X'50'?
         BNE   LOOPNT50             No. Then current card not complete.
*                                   Yes. Then PUT out card and init it.
         S     R8,=F'80'            -80 bytes because new card PUT out
         ST    R10,SAVER10          Save register for safety
         L     R10,FKOUTDCB         Point to FAKEOUT DCB in caller
         L     R1,FLDSCARD          Load address of card
         MVC   WORKAREA(80),0(R1)   Move full card image to workarea
         TM    FLDREADF,X'01'       Is this a READ only run?
         BO    NOPUT001             Yes. Can't PUT to FAKEOUT.
         PUT   (10),WORKAREA        PUT the card image to output file
NOPUT001 DS    0H
         L     R10,SAVER10          Restore R10
         AP    FLDOUTCT,=P'1'       Count of FAKEOUT records written
         L     R7,SAVEBEGC          Point to beginning address of card
         MVC   0(80,R7),ZEROCARD    Initialize card image for next move
         XR    R6,R6                Clear R6
         ST    R6,FLDOFFST          New offset is 0, not X'50'
LOOPNT50 DS    0H
* -- >
         L     R1,FLDBYTOT          Before return, lessen FLDBYTOT
         S     R1,FLDBYMVD          And subtract bytes already moved
         ST    R1,FLDBYTOT          To show new total buffer byte count
*        MVC   LINE+1(8),=C'LSHRT2: '   **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         B     RETURN
*
LOOPMORE DS    0H                   Data move if more than one card
*
         L     R6,SAVEENDC          We're going past end-of-card
         SR    R6,R7                Subtract beg address of data
         C     R6,=F'80'            Still bigger than 80?
         BH    LOOPERR1             Yes. Has to be error.
         BCTR  R6,0                 Subtract one for EXECUTE
         EX    R6,MOVEBUFF          Move data into buffer
         LA    R6,1(,R6)            Restore byte count
         L     R1,FLDBYMVD          Increment
         AR    R1,R6                  total
         ST    R1,FLDBYMVD              bytes moved
         LA    R3,0(R6,R3)          Bop past data moved in buffer
*        MVC   LINE+1(8),=C'LMORE1: '  **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         C     R3,HYPOENDB          Test if past end of buffer
         BH    LOOPERR3             Yes. Has to be an error.
         ST    R3,FLDBUFFR          Re-point current buffer address.
         S     R8,=F'80'            -80 bytes because new card PUT out
         ST    R10,SAVER10          Save register for safety
         L     R10,FKOUTDCB         Point to FAKEOUT DCB in caller
         L     R1,FLDSCARD          Load address of card
         MVC   WORKAREA(80),0(R1)   Move full card image to workarea
         TM    FLDREADF,X'01'       Is this a READ only run?
         BO    NOPUT002             Yes. Then don't produce FAKEOUT.
         PUT   (10),WORKAREA        PUT the card image to output file
NOPUT002 DS    0H
         L     R10,SAVER10          Restore R10
         AP    FLDOUTCT,=P'1'       Count of FAKEOUT records written
         L     R7,SAVEBEGC          Point to beginning address of card
         MVC   0(80,R7),ZEROCARD    Initialize card image for next move
*        MVC   LINE+1(8),=C'LMORE2: '  **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         C     R8,SAVEENDC          Is R8 within the card image end?
         BH    LOOPMORE             No. Do the LOOPMORE routine.
         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.
         SPACE 3
* ----------------------------------------------------------------- *
MOVEBUFF MVC   0(*-*,R7),0(R3)      << EXECUTED >>
* --------------------------------------------------------- *
LOOPERR1 DS    0H                   Error entry location
         MVC   LINE,LINE-1             **  Diagnostic  **
         MVC   LINE+1(9),=C'LOOPERR1 '
         BAL   R9,FLDIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
LOOPERR2 DS    0H                   Error entry location
         MVC   LINE,LINE-1             **  Diagnostic  **
         MVC   LINE+1(9),=C'LOOPERR2 '
         BAL   R9,FLDIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
LOOPERR3 DS    0H                   Error entry location
         MVC   LINE,LINE-1
         MVC   LINE+1(9),=C'LOOPERR3 ' **  Diagnostic  **
         BAL   R9,FLDIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
* --------------------------------------------------------- *
RETURN   DS    0H                   RETURN TO THE CALLER
         ST    R10,SAVER10          Save register for safety
         L     R10,SAVEPARM         Address of FLDAREA in caller
         MVC   0(FLDLENTH,R10),FLDAREA    Copy changed FLDAREA back
         L     R10,SAVER10          Restore R10
         L     R13,4(,R13)
         MVC   16(4,R13),=F'0'      Load Maximum Return Code
         MVC   24(4,R13),=A(FLDBLOCK)  Return address of FLDAREA in R1.
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
* --------------------------------------------------------- *
* --------------------------------------------------------- *
* ---      S U B R O U T I N E S                        --- *
* --------------------------------------------------------- *
FLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently
*
         HEX   LINE+10,4,FLDSCARD
         HEX   LINE+20,4,FLDECARD
         HEX   LINE+30,4,FLDOFFST
         HEX   LINE+40,4,FLDBYTES
         HEX   LINE+50,4,FLDBYTOT
         HEX   LINE+60,4,FLDBYMVD
         HEX   LINE+70,4,FLDBUFFR
         HEX   LINE+80,4,FLDBSTRT
         HEX   LINE+90,7,FLDOUTCT
         HEX   LINE+106,1,FLDREADF
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
         BR    R9
* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *
FLDBLOCK CSECT
FLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK
*                           ------ ---- ------- -----
FLDSCARD DC    F'0'         Start address of 80-byte card
FLDECARD DC    F'0'         End address of 80-byte card
FLDOFFST DC    F'0'         OFFSET of data in the card
FLDBYTES DC    F'0'         Number of bytes to be folded now
FLDBYTOT DC    F'0'         Batch total of bytes left to move
FLDBYMVD DC    F'0'         Number of bytes folded now
FLDBUFFR DC    F'0'         Current data start address
FLDBSTRT DC    F'0'         Original start data address
FLDOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records
FLDREADF DC    X'00'        This run is "READ ONLY"  ?
*              X'01'        Yes, read only.
FLDLENTH EQU   *-FLDAREA
*
FOLDEM   CSECT
WORKAREA DS    CL80                 Card image work area
         DC    CL4' '               Padding
         DC    C' '
LINE     DC    CL133' '             Output line
         DC    C' '
LINE2    DC    CL133' '             Second output line if needed
*
FF       EQU   X'FF'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         BR    R4                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEXSAVE  DS    3F                    Register save for HEX macro
SAVER04  DS    H                     Register save for HEX macro
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ZEROCARD DC    80X'30'
SAVEBEGO DC    F'0'                 Save beg address of card output
SAVEBEGC DC    F'0'                 Save beg address of card
SAVEENDC DC    F'0'                 Save end address of card
SAVEPARM DC    F'0'                 Save CALLER'S FLDAREA address
HYPOENDC DC    F'0'                 Hypothetical end address after card
HYPOENDB DC    F'0'                 Calculated end of buffer address
SYSPRINV DC    V(SYSPRINT)          Address of SYSPRINT DCB
FAKEOUTV DC    V(FAKEOUT)           Address of FAKEOUT DCB
SYSPRDCB DC    F'0'                 SYSPRINT DCB address stored here
FKOUTDCB DC    F'0'                 FAKEOUT DCB address stored here
SAVER10  DC    F'0'
         END
